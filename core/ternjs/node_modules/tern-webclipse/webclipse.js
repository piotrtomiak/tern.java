"use strict";

var infer = require("tern/lib/infer");
var tern = require("tern/lib/tern");
var walk = require("acorn/dist/walk");
var syntax_val = require("./acorn_val.js");
var semantic_highlight = require("./semantic_highlight.js");
var call_hierarchy = require("./call_hierarchy.js");  
  
  
  // Validator
function validate(server, query, file, messages, strictParserError) {
  function makeError(msg, start, end) {
	  if (start > end) {
		  var tmp = start;
		  start = end
		  end = tmp;
	  }
	  if (start == end) {
		  end = start + 1;
	  }
	  if (end >= file.text.length) {
		  end = file.text.length;
		  if (start >= end) {
			  start = end - 1;
		  }
	  }
      var error = {
          message: msg,
          from: tern.outputPos(query, file, start),
          to: tern.outputPos(query, file, end),
          severity: "error"
	  };
	  if (query.lineNumber) {
	    error.lineNumber = 1 + query.lineCharPositions ? error.from.line : tern.outputPos({lineCharPositions: true}, file, start).line; 
	  }
	  if (!query.groupByFiles) error.file = file.name;
	  return error;
  }
  
  var options = {
      directSourceFile: file,
      allowReturnOutsideFunction: true,
      allowImportExportEverywhere: true,
      ecmaVersion: server.options.ecmaVersion
  }
  var text = server.signalReturnFirst("preParse", file.text, options) || file.text;
  text = tern.removeShebang(text);
  var err_msgs = syntax_val.validate_syntax(text, options);
  /* for debugging purposes
  if (strictParserError && !err_msgs[strictParserError.pos]) {
	  err_msgs[strictParserError.pos] = {
			  message: "[Raw] " + strictParserError.message.replace(/\(\d*\:\d*\)$/, ""),
			  start: strictParserError.pos,
			  end: strictParserError.raisedAt
	  }
  } */
  for (var id in err_msgs) {
	  var msg = err_msgs[id];
	  messages.push(makeError(msg.message, msg.start, msg.end));
  }
  if (messages.length == 0 && strictParserError) {
	  messages.push(makeError(strictParserError.message.replace(/\(\d*\:\d*\)$/, "[Strict]"), 
    			  strictParserError.pos, strictParserError.raisedAt))
  }
}
  
  // Validate one file
var validateFile = exports.validateFile = function(server, query, file) {
    try {
      var messages = [], ast = file.ast, state = file.scope;
// if (ast.error) {
	  validate(server, query, file, messages, ast.error);
// }
      return {messages: messages};
    } catch(err) {
      console.error(err.stack);
      return {messages: []};
    }
}
  
//  // Validate the whole files of the server
//  var validateFiles = exports.validateFiles = function(server, query) {
//	try {
//		var messages = [], files = server.files, groupByFiles = query.groupByFiles == true;
//		for (var i = 0; i < files.length; ++i) {
//			var messagesFile = groupByFiles ? [] : messages, file = files[i], state = file.scope;
//			var visitor = createVisitor(server, query, file, messagesFile);
//			walk.simple(ast, visitor, infer.searchVisitor, state);
//			if (groupByFiles)
//				messages.push({
//					file : file.name,
//					messages : messagesFile
//				});
//		}
//		return {messages : messages};
//	} catch (err) {
//		console.error(err.stack);
//		return {messages : []};
//	}
//}
  
tern.defineQueryType("syntax-val", {
    takesFile: true,
    noInfer: true,
    run: function(server, query, file) {
      return validateFile(server, query, file);  
    }
});

tern.defineQueryType("semantic-highlight", {
	takesFile: true,
    noInfer: true,
    run: function(server, query, file) {
      return semantic_highlight.calculate(file.ast);
    }
});

tern.defineQueryType("call-hierarchy-roots", {
	takesFile: true,
    run: function(server, query, file) {
      return call_hierarchy.findRoots(server, query, file);
    }
});

tern.defineQueryType("call-hierarchy-callers", {
	takesFile: true,
    run: function(server, query, file) {
      return call_hierarchy.findCallers(server, query, file);
    }
});

tern.defineQueryType("call-hierarchy-callees", {
	takesFile: true,
    run: function(server, query, file) {
      return call_hierarchy.findCallees(server, query, file);
    }
});
  
tern.registerPlugin("webclipse", function(server, options) {	
    server._webclipse = {};
});
  