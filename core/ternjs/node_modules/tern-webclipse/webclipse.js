"use strict";

var infer = require("tern/lib/infer");
var tern = require("tern/lib/tern");
var walk = require("acorn/dist/walk");
var syntax_val = require("./acorn_val.js");
var semantic_highlight = require("./semantic_highlight.js");
var call_hierarchy = require("./call_hierarchy.js");
var code_folding = require("./code_folding.js");
var outline = require("./outline.js");
var push = require("tern-push/push.js");
  
// Validator
function validate(server, query, file, messages, strictParserError) {
  function makeError(msg, start, end) {
	  if (start > end) {
		  var tmp = start;
		  start = end
		  end = tmp;
	  }
	  if (start == end) {
		  end = start + 1;
	  }
	  if (end >= file.text.length) {
		  end = file.text.length;
		  if (start >= end) {
			  start = end - 1;
		  }
	  }
      var error = {
          message: msg,
          from: tern.outputPos(query, file, start),
          to: tern.outputPos(query, file, end),
          severity: "error"
	  };
	  if (query.lineNumber) {
	    error.lineNumber = 1 + query.lineCharPositions ? error.from.line : tern.outputPos({lineCharPositions: true}, file, start).line; 
	  }
	  if (!query.groupByFiles) error.file = file.name;
	  return error;
  }
  
  var options = {
      directSourceFile: file,
      allowReturnOutsideFunction: true,
      allowImportExportEverywhere: true,
      ecmaVersion: server.options.ecmaVersion
  }
  var text = server.signalReturnFirst("preParse", file.text, options) || file.text;
  text = tern.removeShebang(text);
  var err_msgs = syntax_val.validate_syntax(text, options);
  /* for debugging purposes
  if (strictParserError && !err_msgs[strictParserError.pos]) {
	  err_msgs[strictParserError.pos] = {
			  message: "[Raw] " + strictParserError.message.replace(/\(\d*\:\d*\)$/, ""),
			  start: strictParserError.pos,
			  end: strictParserError.raisedAt
	  }
  } */
  for (var id in err_msgs) {
	  var msg = err_msgs[id];
	  messages.push(makeError(msg.message, msg.start, msg.end));
  }
  if (messages.length == 0 && strictParserError) {
	  messages.push(makeError(strictParserError.message.replace(/\(\d*\:\d*\)$/, "[Strict]"), 
    			  strictParserError.pos, strictParserError.raisedAt))
  }
}
  
  // Validate one file
var validateFile = exports.validateFile = function(server, query, file) {
  try {
    var messages = [], ast = file.ast, state = file.scope;
// if (ast.error) {
    validate(server, query, file, messages, ast.error);
// }
    return {messages: messages};
  } catch(err) {
    console.error(err.stack);
    return {messages: []};
  }
}
  
tern.defineQueryType("syntax-val", {
  takesFile: true,
  noInfer: true,
  run: function(server, query, file) {
    return validateFile(server, query, file);  
  }
});

tern.defineQueryType("semantic-highlight", {
  takesFile: true,
  noInfer: true,
  run: function(server, query, file) {
    return semantic_highlight.calculate(file.ast);
  }
});

tern.defineQueryType("call-hierarchy-roots", {
	takesFile: true,
    run: function(server, query, file) {
      return call_hierarchy.findRoots(server, query, file);
    }
});

tern.defineQueryType("code-folding", {
	takesFile: true,
    run: function(server, query, file) {
      return code_folding.computeCodeFolding(file.ast);
    }
});

tern.defineQueryType("call-hierarchy-callers", {
	takesFile: true,
    run: function(server, query, file) {
      return call_hierarchy.findCallers(server, query, file);
    }
});

tern.defineQueryType("call-hierarchy-callees", {
  takesFile: true,
  run: function(server, query, file) {
    return call_hierarchy.findCallees(server, query, file);
  }
});

tern.defineQueryType("webclipse-outline", {
  takesFile: true,
  run: function(server, query, file) {
    return outline.create(query, file);
  }
});
  
tern.registerPlugin("webclipse", function(server, options) {	
    server._webclipse = {};
    server.on("postParse", postParse)
});

function postParse(ast, scope) {
	var server = infer.cx().parent;
	if (server.sendToClient) {
		var data = {};
		server.sendToClient("webclipse:astChanged", data);
	}
}
